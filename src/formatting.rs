use std::path::PathBuf;
use crate::{RuleContextInfo, Result};

/// Trait for types that can be formatted into different output formats
pub trait Formattable {
    /// Format the object into the specified format
    fn format_with(&self, formatter: &dyn OutputFormatter) -> Result<String>;
}

/// Trait for formatters that can render content in specific formats
pub trait OutputFormatter {
    /// Format a context for a specific file path
    fn format_context(
        &self,
        path: &PathBuf,
        rules: &[RuleContextInfo],
        inheritance_chain: &[PathBuf],
        overridden_rules: &[String],
    ) -> String;
    
    /// Format a collection of rules as a list
    fn format_rules(&self, rules: &[RuleContextInfo]) -> String;
    
    /// Format a single rule
    fn format_rule(&self, rule: &RuleContextInfo) -> String;
    
    /// Get the format name (e.g., "markdown", "json", "plain")
    fn format_name(&self) -> &'static str;
}

/// Markdown formatter for human-readable documentation
pub struct MarkdownFormatter;

impl OutputFormatter for MarkdownFormatter {
    fn format_context(
        &self,
        path: &PathBuf,
        rules: &[RuleContextInfo],
        inheritance_chain: &[PathBuf],
        overridden_rules: &[String],
    ) -> String {
        let mut output = String::new();
        
        output.push_str("# Synapse Rule Enforcement Context\n\n");
        output.push_str(&format!("**File:** `{}`\n\n", path.display()));
        
        if !inheritance_chain.is_empty() {
            output.push_str(&format!("**Rule Inheritance:** {}\n\n", 
                inheritance_chain
                    .iter()
                    .map(|p| format!("`{}`", p.display()))
                    .collect::<Vec<_>>()
                    .join(" â†’ ")
            ));
        }
        
        if rules.is_empty() {
            output.push_str("## No Rules Apply\n\nNo specific rules are configured for this file path.\n");
            return output;
        }
        
        // Group rules by enforcement level
        let blocking_rules: Vec<_> = rules.iter().filter(|r| r.enforcement_level == "BLOCKING").collect();
        let suggestion_rules: Vec<_> = rules.iter().filter(|r| r.enforcement_level == "SUGGESTION").collect();
        let style_rules: Vec<_> = rules.iter().filter(|r| r.enforcement_level == "STYLE").collect();
        
        if !blocking_rules.is_empty() {
            output.push_str("## ðŸš« Blocking Rules (Enforced)\n\n");
            for rule in blocking_rules {
                output.push_str(&format!("### {} ({})\n", rule.name, rule.rule_type_display()));
                output.push_str(&format!("**Pattern:** `{}`\n", rule.pattern));
                output.push_str(&format!("**Message:** {}\n\n", rule.message));
            }
        }
        
        if !suggestion_rules.is_empty() {
            output.push_str("## ðŸ’¡ Standards & Suggestions\n\n");
            for rule in suggestion_rules {
                output.push_str(&format!("### {} ({})\n", rule.name, rule.rule_type_display()));
                output.push_str(&format!("**Pattern:** `{}`\n", rule.pattern));
                output.push_str(&format!("**Message:** {}\n\n", rule.message));
            }
        }
        
        if !style_rules.is_empty() {
            output.push_str("## ðŸŽ¨ Style Conventions\n\n");
            for rule in style_rules {
                output.push_str(&format!("### {} ({})\n", rule.name, rule.rule_type_display()));
                output.push_str(&format!("**Pattern:** `{}`\n", rule.pattern));
                output.push_str(&format!("**Message:** {}\n\n", rule.message));
            }
        }
        
        if !overridden_rules.is_empty() {
            output.push_str("## âš ï¸ Overridden Rules\n\n");
            for rule_id in overridden_rules {
                output.push_str(&format!("- `{}`\n", rule_id));
            }
            output.push_str("\n");
        }
        
        output.push_str("---\n");
        output.push_str("*Generated by Synapse MCP PatternEnforcer*\n");
        
        output
    }
    
    fn format_rules(&self, rules: &[RuleContextInfo]) -> String {
        let mut output = String::new();
        output.push_str("# Rules\n\n");
        
        for rule in rules {
            output.push_str(&self.format_rule(rule));
            output.push_str("\n");
        }
        
        output
    }
    
    fn format_rule(&self, rule: &RuleContextInfo) -> String {
        format!(
            "## {} ({})\n\n**Pattern:** `{}`\n**Message:** {}\n**Tags:** {}\n",
            rule.name,
            rule.rule_type_display(),
            rule.pattern,
            rule.message,
            rule.tags.join(", ")
        )
    }
    
    fn format_name(&self) -> &'static str {
        "markdown"
    }
}

/// JSON formatter for machine-readable data interchange
pub struct JsonFormatter;

impl OutputFormatter for JsonFormatter {
    fn format_context(
        &self,
        path: &PathBuf,
        rules: &[RuleContextInfo],
        inheritance_chain: &[PathBuf],
        overridden_rules: &[String],
    ) -> String {
        let context = serde_json::json!({
            "file": path.display().to_string(),
            "rules": rules,
            "inheritance_chain": inheritance_chain.iter().map(|p| p.display().to_string()).collect::<Vec<_>>(),
            "overridden_rules": overridden_rules,
            "rule_count": rules.len(),
            "format": "json"
        });
        
        serde_json::to_string_pretty(&context).unwrap_or_else(|_| "{}".to_string())
    }
    
    fn format_rules(&self, rules: &[RuleContextInfo]) -> String {
        serde_json::to_string_pretty(rules).unwrap_or_else(|_| "[]".to_string())
    }
    
    fn format_rule(&self, rule: &RuleContextInfo) -> String {
        serde_json::to_string_pretty(rule).unwrap_or_else(|_| "{}".to_string())
    }
    
    fn format_name(&self) -> &'static str {
        "json"
    }
}

/// Plain text formatter for simple, readable output
pub struct PlainFormatter;

impl OutputFormatter for PlainFormatter {
    fn format_context(
        &self,
        path: &PathBuf,
        rules: &[RuleContextInfo],
        inheritance_chain: &[PathBuf],
        overridden_rules: &[String],
    ) -> String {
        let mut output = String::new();
        
        output.push_str(&format!("File: {}\n", path.display()));
        output.push_str(&format!("Rules: {}\n", rules.len()));
        
        if !inheritance_chain.is_empty() {
            output.push_str(&format!("Inheritance: {}\n", 
                inheritance_chain
                    .iter()
                    .map(|p| p.display().to_string())
                    .collect::<Vec<_>>()
                    .join(" -> ")
            ));
        }
        
        if !overridden_rules.is_empty() {
            output.push_str(&format!("Overridden: {}\n", overridden_rules.join(", ")));
        }
        
        output.push_str("\n");
        
        for rule in rules {
            output.push_str(&format!("{} ({}): {} - {}\n",
                rule.name,
                rule.rule_type_display(),
                rule.pattern,
                rule.message
            ));
        }
        
        output
    }
    
    fn format_rules(&self, rules: &[RuleContextInfo]) -> String {
        let mut output = String::new();
        
        for rule in rules {
            output.push_str(&self.format_rule(rule));
            output.push_str("\n");
        }
        
        output
    }
    
    fn format_rule(&self, rule: &RuleContextInfo) -> String {
        format!("{}: {} - {}", rule.name, rule.pattern, rule.message)
    }
    
    fn format_name(&self) -> &'static str {
        "plain"
    }
}

/// Factory function to create formatters by name
pub fn get_formatter(format_name: &str) -> Box<dyn OutputFormatter> {
    match format_name.to_lowercase().as_str() {
        "markdown" | "md" => Box::new(MarkdownFormatter),
        "json" => Box::new(JsonFormatter),
        "plain" | "text" => Box::new(PlainFormatter),
        _ => Box::new(MarkdownFormatter), // Default to markdown
    }
}

/// Context data that can be formatted
pub struct FormattableContext {
    pub path: PathBuf,
    pub rules: Vec<RuleContextInfo>,
    pub inheritance_chain: Vec<PathBuf>,
    pub overridden_rules: Vec<String>,
}

impl Formattable for FormattableContext {
    fn format_with(&self, formatter: &dyn OutputFormatter) -> Result<String> {
        Ok(formatter.format_context(
            &self.path,
            &self.rules,
            &self.inheritance_chain,
            &self.overridden_rules,
        ))
    }
}

impl Formattable for Vec<RuleContextInfo> {
    fn format_with(&self, formatter: &dyn OutputFormatter) -> Result<String> {
        Ok(formatter.format_rules(self))
    }
}

impl Formattable for RuleContextInfo {
    fn format_with(&self, formatter: &dyn OutputFormatter) -> Result<String> {
        Ok(formatter.format_rule(self))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::RuleType;

    fn create_test_rule() -> RuleContextInfo {
        RuleContextInfo {
            name: "no-println".to_string(),
            rule_type: RuleType::Forbidden,
            pattern: "println!(".to_string(),
            message: "Use logging instead".to_string(),
            tags: vec!["style".to_string(), "logging".to_string()],
            enforcement_level: "BLOCKING".to_string(),
        }
    }

    #[test]
    fn test_markdown_formatter() {
        let formatter = MarkdownFormatter;
        let rule = create_test_rule();
        
        let formatted = formatter.format_rule(&rule);
        assert!(formatted.contains("# no-println"));
        assert!(formatted.contains("println!("));
        assert!(formatted.contains("FORBIDDEN"));
    }

    #[test]
    fn test_json_formatter() {
        let formatter = JsonFormatter;
        let rule = create_test_rule();
        
        let formatted = formatter.format_rule(&rule);
        let parsed: serde_json::Value = serde_json::from_str(&formatted).unwrap();
        
        assert_eq!(parsed["name"], "no-println");
        assert_eq!(parsed["pattern"], "println!(");
    }

    #[test]
    fn test_plain_formatter() {
        let formatter = PlainFormatter;
        let rule = create_test_rule();
        
        let formatted = formatter.format_rule(&rule);
        assert!(formatted.contains("no-println"));
        assert!(formatted.contains("println!("));
        assert!(formatted.contains("Use logging instead"));
    }

    #[test]
    fn test_get_formatter() {
        assert_eq!(get_formatter("markdown").format_name(), "markdown");
        assert_eq!(get_formatter("json").format_name(), "json");
        assert_eq!(get_formatter("plain").format_name(), "plain");
        assert_eq!(get_formatter("unknown").format_name(), "markdown"); // defaults to markdown
    }

    #[test]
    fn test_formattable_context() {
        let context = FormattableContext {
            path: PathBuf::from("/test/main.rs"),
            rules: vec![create_test_rule()],
            inheritance_chain: vec![],
            overridden_rules: vec![],
        };
        
        let formatter = MarkdownFormatter;
        let formatted = context.format_with(&formatter).unwrap();
        
        assert!(formatted.contains("# Synapse Rule Enforcement Context"));
        assert!(formatted.contains("/test/main.rs"));
        assert!(formatted.contains("no-println"));
    }

    #[test]
    fn test_formattable_rules() {
        let rules = vec![create_test_rule()];
        let formatter = JsonFormatter;
        
        let formatted = rules.format_with(&formatter).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&formatted).unwrap();
        
        assert!(parsed.is_array());
        assert_eq!(parsed[0]["name"], "no-println");
    }
}