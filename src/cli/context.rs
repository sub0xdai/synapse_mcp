use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use anyhow::Result;

#[derive(Debug, Serialize, Deserialize)]
pub struct ContextData {
    pub scope: String,
    pub generated_at: DateTime<Utc>,
    pub sections: Vec<ContextSection>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ContextSection {
    pub title: String,
    pub items: Vec<ContextItem>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ContextItem {
    pub title: String,
    pub content: String,
    pub item_type: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub file_path: Option<String>,
}

pub fn format_as_markdown(context: &ContextData, scope: &str) -> Result<String> {
    let mut output = String::new();
    
    // Header
    output.push_str("# SYNAPSE AI CONTEXT\n\n");
    output.push_str(&format!("**Scope**: {}\n", scope));
    output.push_str(&format!("**Generated**: {}\n", context.generated_at.format("%Y-%m-%d %H:%M:%S UTC")));
    output.push_str(&format!("**Sections**: {}\n\n", context.sections.len()));
    
    output.push_str("This context provides AI-readable project documentation and guidelines.\n\n");
    output.push_str("---\n\n");
    
    // Content sections
    for section in &context.sections {
        output.push_str(&format!("## {}\n\n", section.title));
        
        for item in &section.items {
            output.push_str(&format!("### {}\n\n", item.title));
            
            // Add metadata if available
            if !item.tags.is_empty() {
                output.push_str(&format!("**Tags**: {}\n\n", item.tags.join(", ")));
            }
            
            // Add the content
            let content = item.content.trim();
            if !content.is_empty() {
                // Skip YAML frontmatter if present
                let clean_content = if content.starts_with("---\n") {
                    if let Some(end_pos) = content[4..].find("\n---\n") {
                        content[end_pos + 8..].trim()
                    } else {
                        content
                    }
                } else {
                    content
                };
                
                output.push_str(clean_content);
                output.push_str("\n\n");
            }
        }
    }
    
    // Footer
    output.push_str("---\n\n");
    output.push_str("*Generated by Synapse AI Workspace Framework*\n");
    
    Ok(output)
}

pub fn format_as_json(context: &ContextData) -> Result<String> {
    let json = serde_json::to_string_pretty(context)?;
    Ok(json)
}

pub fn format_as_plain(context: &ContextData) -> Result<String> {
    let mut output = String::new();
    
    output.push_str(&format!("SYNAPSE AI CONTEXT ({})\n", context.scope));
    output.push_str(&format!("Generated: {}\n\n", context.generated_at.format("%Y-%m-%d %H:%M:%S UTC")));
    
    for section in &context.sections {
        output.push_str(&format!("{}\n", "=".repeat(section.title.len() + 4)));
        output.push_str(&format!("  {}\n", section.title));
        output.push_str(&format!("{}\n\n", "=".repeat(section.title.len() + 4)));
        
        for item in &section.items {
            output.push_str(&format!("{}\n", item.title));
            output.push_str(&format!("{}\n", "-".repeat(item.title.len())));
            
            if !item.tags.is_empty() {
                output.push_str(&format!("Tags: {}\n", item.tags.join(", ")));
            }
            
            output.push_str("\n");
            
            // Clean content (remove YAML frontmatter)
            let content = item.content.trim();
            let clean_content = if content.starts_with("---\n") {
                if let Some(end_pos) = content[4..].find("\n---\n") {
                    content[end_pos + 8..].trim()
                } else {
                    content
                }
            } else {
                content
            };
            
            // Convert markdown to plain text (basic conversion)
            let plain_content = clean_content
                .replace("## ", "")
                .replace("### ", "")
                .replace("#### ", "")
                .replace("**", "")
                .replace("*", "");
                
            output.push_str(&plain_content);
            output.push_str("\n\n");
        }
    }
    
    Ok(output)
}

pub fn extract_frontmatter(content: &str) -> (HashMap<String, String>, String) {
    let mut metadata = HashMap::new();
    let mut body = content;
    
    if content.starts_with("---\n") {
        if let Some(end_pos) = content[4..].find("\n---\n") {
            let frontmatter = &content[4..end_pos + 4];
            body = content[end_pos + 8..].trim();
            
            // Parse YAML frontmatter (simple key: value parsing)
            for line in frontmatter.lines() {
                if let Some(colon_pos) = line.find(':') {
                    let key = line[..colon_pos].trim();
                    let value = line[colon_pos + 1..].trim().trim_matches('"');
                    metadata.insert(key.to_string(), value.to_string());
                }
            }
        }
    }
    
    (metadata, body.to_string())
}

pub fn create_context_item_from_file(content: &str, file_path: &std::path::Path) -> Result<ContextItem> {
    let (metadata, body) = extract_frontmatter(content);
    
    // Extract title from metadata or use first heading or filename
    let title = metadata.get("title")
        .cloned()
        .unwrap_or_else(|| {
            // Try to extract from first heading
            for line in body.lines() {
                if line.starts_with("# ") {
                    return line[2..].trim().to_string();
                }
            }
            
            // Fallback to filename
            file_path.file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("Untitled")
                .to_string()
        });
    
    // Extract tags
    let tags = metadata.get("tags")
        .map(|t| {
            // Simple parsing: assume comma-separated or JSON array
            if t.starts_with('[') && t.ends_with(']') {
                // JSON-like array parsing
                t[1..t.len()-1]
                    .split(',')
                    .map(|s| s.trim().trim_matches('"'))
                    .filter(|s| !s.is_empty())
                    .map(|s| s.to_string())
                    .collect()
            } else {
                // Comma-separated
                t.split(',')
                    .map(|s| s.trim().to_string())
                    .filter(|s| !s.is_empty())
                    .collect()
            }
        })
        .unwrap_or_default();
    
    let item_type = metadata.get("type")
        .cloned()
        .unwrap_or_else(|| "document".to_string());
    
    Ok(ContextItem {
        title,
        content: body,
        item_type,
        tags,
        metadata,
        file_path: Some(file_path.to_string_lossy().to_string()),
    })
}